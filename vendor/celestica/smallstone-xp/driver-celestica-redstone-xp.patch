Add Celestica Redstone-xp cpld drivers.Add delay in Intel i2c-ismt driver in case of no status rerurn from smbus controller.

From: https://raw.githubusercontent.com/opencomputeproject/onie/master/machine/celestica/cel_smallstone_xp/kernel/driver-celestica-redstone-xp.patch
At: 856e0ac26ff78f8d033331b1bde9ccbe45a3530c
SPDX-License-Identifier: GPL-2.0

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 26956c006987..43f3bcf7cabf 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -303,6 +303,14 @@ config EFI_RTC
 
 endif # RTC_LIB
 
+config CEL_REDSTONE_XP_CPLD
+	tristate "Celestica Redstone XP Platform CPLD Support"
+	depends on X86 && PCI
+	---help---
+	 Enable support for Celestica Redstone XP switching platform.
+	 This platform has a c2000 Atom (Rangeley) CPU module, a Broadcom
+	 Trident2 switch ASIC and 48x10G SFP + 6x40G QSFP ports.
+	 
 config DTLK
 	tristate "Double Talk PC internal speech card support"
 	depends on ISA
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7c5ea6f9df14..16fc3a7b54ec 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -52,3 +52,4 @@ js-rtc-y = rtc.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-$(CONFIG_CEL_REDSTONE_XP_CPLD)     += cel-redstone-xp-cpld.o
diff --git a/drivers/char/cel-redstone-xp-cpld.c b/drivers/char/cel-redstone-xp-cpld.c
new file mode 100755
index 000000000000..9d24c7a4ac44
--- /dev/null
+++ b/drivers/char/cel-redstone-xp-cpld.c
@@ -0,0 +1,583 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/compat.h>
+
+#ifdef DEBUG_CLS
+# define DEBUG(fmt, ...) printk(fmt, ##__VA_ARGS__)
+#else
+# define DEBUG(fmt, ...)
+#endif
+
+#define IO_BASE		0x00
+#define CPLD_IO_OFF_1	0x100
+#define CPLD_IO_REGION_1 (0x2f8-0x100)
+#define CPLD_IO_OFF_2	0x300
+#define CPLD_IO_REGION_2	(0x3c0-0x300)
+#define CPLD_IO_OFF_3	0x3e0
+#define CPLD_IO_REGION_3	(0x3f0-0x3e0)
+#define CPLD_MINOR 0
+
+struct cpld_dev
+{
+	uint16_t ioBase;
+	struct cdev cdev;
+	dev_t dev;
+};
+
+typedef struct RegData
+{
+	uint16_t regId;			/*register number*/
+	char val;		    	/*register value*/
+	uint8_t rw;			  	/*0:read 1:write*/
+}RegData_t;
+
+typedef struct SfpData
+{
+	char regId;
+	int portId;
+	char devAddr;
+	char val[256];
+	uint8_t rw;
+	uint8_t len;
+}SfpData_t;
+
+#define CPLD_TYPE														( 0x89 )
+#define IOCTL_READ_REG                      _IOR(CPLD_TYPE,0x05,RegData_t)
+#define IOCTL_WRITE_REG                     _IOW(CPLD_TYPE,0x08,RegData_t)
+#define IOCTL_SFP_READ                      _IOR(CPLD_TYPE,0x0F,RegData_t)
+#define IOCTL_SFP_WRITE                     _IOW(CPLD_TYPE,0x10,RegData_t)
+
+//DEFINE_MUTEX(cpld_mutex);
+static struct mutex cpld_mutex;
+#define CPLD_MAJOR 0
+static int debug = 0;
+module_param(debug, int, 0644);
+
+static int major = 0;
+static int cpld_major = CPLD_MAJOR;
+/* 0 = Dynamic allocation of the major device number */
+
+module_param(major, int, 0644);
+
+#ifdef TEST
+static phys_addr_t io_base = IO_BASE;
+#endif
+static int use_count = 0;
+
+static int sfp_read(int ioBase, int portID, char devAddr, char reg, char *data, int len)
+{
+	int count;
+	char byte;
+	short temp;
+	short portid, opcode, devaddr, cmdbyte0, ssrr, writedata, readdata;
+
+		DEBUG("sfp_read sfp iobase=0x%x\n",ioBase);
+	if ((reg + len) > 256) {
+		printk(KERN_ERR "read data len not larger than 256!\n");
+		return -1;
+	}
+	if ((portID >= 1) && (portID <= 18)) {
+		portid = 0x210;
+		opcode = 0x211;
+		devaddr = 0x212;
+		cmdbyte0 = 0x213;
+		ssrr = 0x216;
+		writedata = 0x220;
+		readdata = 0x230;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+	printk(KERN_ERR "I2C master read busy!\n");
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 19) && (portID <= 36)) {
+		portid = 0x290;
+		opcode = 0x291;
+		devaddr = 0x292;
+		cmdbyte0 = 0x293;
+		ssrr = 0x296;
+		writedata = 0x2A0;
+		readdata = 0x2B0;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 37) && (portID <= 48)) {
+		portid = 0x390;
+		opcode = 0x391;
+		devaddr = 0x392;
+		cmdbyte0 = 0x393;
+		ssrr = 0x396;
+		writedata = 0x3A0;
+		readdata = 0x3B0;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 49) && (portID <= 54)) {
+		portid = 0x310;
+		opcode = 0x311;
+		devaddr = 0x312;
+		cmdbyte0 = 0x313;
+		ssrr = 0x316;
+		writedata = 0x320;
+		readdata = 0x330;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else {
+		printk(KERN_ERR "sfp num be sure in 1-54,but input is %d\n", portID);
+		return -1;
+	}
+	DEBUG("Start to read\n");
+	byte = 0x40 + portID;
+	outb(byte, ioBase + portid);
+	outb(reg,ioBase + cmdbyte0);
+	while (len > 0) {
+		count = (len >= 8) ? 8 : len;
+		len -= count;
+		byte = count * 16 + 1;
+		outb(byte, ioBase + opcode);
+		devAddr |= 0x01;
+		outb(devAddr, ioBase + devaddr);
+		while ((inb(ioBase + ssrr) & 0x40))
+		{
+			udelay(100);
+		}
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			printk(KERN_ERR "I2C Master error!\n");
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+		temp = ioBase + readdata;
+		while (count-- > 0) {
+			char read_byte;
+			read_byte = inb(temp);
+			*(data++) = read_byte;
+			printk("read_byte = %x\n",read_byte);
+			temp++;
+		}
+		if (len > 0) {
+			reg += 0x08;
+			outb(reg, ioBase + cmdbyte0);
+		}
+	}
+	DEBUG("sfp_write read\n");
+	return 0;
+}
+
+static int sfp_write(int ioBase, int portID, char devAddr, char reg, char *data, int len)
+{
+	int count;
+	char byte;
+	short temp;
+	short portid, opcode, devaddr, cmdbyte0, ssrr, writedata, readdata;
+	DEBUG("sfp_write sfp iobase=0x%x\n",ioBase);
+	if ((reg + len) > 256) {
+		printk(KERN_ERR "read data len not larger than 256!\n");
+		return -1;
+	}
+	if ((portID >= 1) && (portID <= 18)) {
+		portid = 0x210;
+		opcode = 0x211;
+		devaddr = 0x212;
+		cmdbyte0 = 0x213;
+		ssrr = 0x216;
+		writedata = 0x220;
+		readdata = 0x230;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 19) && (portID <= 36)) {
+		portid = 0x290;
+		opcode = 0x291;
+		devaddr = 0x292;
+		cmdbyte0 = 0x293;
+		ssrr = 0x296;
+		writedata = 0x2A0;
+		readdata = 0x2B0;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 37) && (portID <= 48)) {
+		portid = 0x390;
+		opcode = 0x391;
+		devaddr = 0x392;
+		cmdbyte0 = 0x393;
+		ssrr = 0x396;
+		writedata = 0x3A0;
+		readdata = 0x3B0;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else if ((portID >= 49) && (portID <= 54)) {
+		portid = 0x310;
+		opcode = 0x311;
+		devaddr = 0x312;
+		cmdbyte0 = 0x313;
+		ssrr = 0x316;
+		writedata = 0x320;
+		readdata = 0x330;
+		while ((inb(ioBase + ssrr) & 0x40));
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+	} else {
+		printk(KERN_ERR "sfp num be sure in 1-54,but input is %d\n", portID);
+		return -1;
+	}
+	byte = 0x40 + portID;
+	outb(byte, ioBase + portid);
+	outb(reg, ioBase + cmdbyte0);
+	while (len > 0) {
+		count = (len >= 8) ? 8 : len;
+		len -= count;
+		byte = (count << 4) + 1;
+		outb(byte, ioBase + opcode);
+		temp = ioBase + writedata;
+		while (count-- > 0) {
+			outb(*(data++), temp);
+			temp += 0x01;
+		}
+		devAddr &= 0xfe;
+		outb(devAddr, ioBase + devaddr);
+		while ((inb(ioBase + ssrr) & 0x40))
+		{
+			udelay(100);
+		}
+		if ((inb(ioBase + ssrr) & 0x80) == 0x80) {
+			printk(KERN_ERR "I2C Master error!\n");
+			outb(0x00, ioBase + ssrr);
+			udelay(3000);
+			outb(0x01, ioBase + ssrr);
+			return -1;
+		}
+		if (len > 0) {
+			reg += 0x08;
+			outb(ioBase + cmdbyte0, reg);
+		}
+	}
+	DEBUG("sfp_write out\n");
+	return 0;
+}
+
+static long cpld_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	int retval;
+	RegData_t buffer;
+	SfpData_t data;
+	//struct cpld_dev *dev;
+	uint16_t ioBase = 0;
+	if ( _IOC_TYPE( cmd ) != CPLD_TYPE ) {
+		return( -ENOTTY );
+	}
+	if ( _IOC_DIR( cmd ) & _IOC_READ ) {
+		err = !access_ok(( void __user * )arg,_IOC_SIZE( cmd ) );
+	} else if ( _IOC_DIR( cmd ) & _IOC_WRITE ) {
+		err = !access_ok(( void __user * )arg,_IOC_SIZE( cmd ) );
+	}
+	if ( err ) {
+		return( -EFAULT );
+	}
+	//dev = filp->private_data;
+	DEBUG("cpld_ioctl cmd=0x%x\n",cmd);
+	switch (cmd) {
+  	case IOCTL_READ_REG: 
+   	{
+   		retval = copy_from_user(&buffer, (const void *)arg, sizeof(RegData_t));
+   		if(retval)
+   			return -EFAULT;
+   		if(buffer.rw == 0){
+   			mutex_lock(&cpld_mutex);
+   			buffer.val = inb(ioBase+buffer.regId);
+				if(debug == 1)
+   				printk(KERN_DEBUG "reg is %x get data is %x\n", ioBase+buffer.regId, buffer.val);
+   			mutex_unlock(&cpld_mutex);
+   			retval = copy_to_user((void __user *)arg, &buffer, sizeof(RegData_t));
+   		}else{
+   			if(debug == 1)
+   				printk(KERN_DEBUG "IOCTL_READ_REG error param.\n");
+   		}
+   		break;
+   	}
+   	case IOCTL_WRITE_REG:
+   	{
+   		retval = copy_from_user(&buffer, (const void *)arg, sizeof(RegData_t));
+   		if(retval)
+   			return -EFAULT;
+   		if(buffer.rw == 1){
+   			mutex_lock(&cpld_mutex);
+				if(debug == 1)
+   				printk(KERN_DEBUG "reg is %x put data is %x\n", ioBase+buffer.regId, buffer.val);
+   			outb(buffer.val, (ioBase+buffer.regId));
+   			mutex_unlock(&cpld_mutex);
+   		}else{
+   			if(debug == 1)
+   				printk(KERN_DEBUG "IOCTL_READ_REG error param.\n");
+   		}
+   		break;
+   	}
+   	case IOCTL_SFP_READ:
+   	{
+			if(debug == 2)
+				printk(KERN_ERR "entry sfp read ioctl\n");
+   		retval = copy_from_user(&data, (const void *)arg, sizeof(SfpData_t));
+   		if(retval){
+			if(debug == 2)
+				printk(KERN_DEBUG "copy from user fail\n");
+   			return -EFAULT;
+		}
+			if(debug == 2)
+				printk(KERN_DEBUG "port id is %d, dev addr is %x, register id is %x\n", data.portId, data.devAddr, data.regId);
+   		if(data.rw == 0){
+				retval = sfp_read(ioBase, data.portId, data.devAddr, data.regId, data.val, data.len);
+				if(retval == 0)
+				{
+					retval = copy_to_user((void __user *)arg, &data, sizeof(data));
+				}else{
+	   			if(debug == 2)
+   					printk(KERN_DEBUG "Access sfp register fail.\n");
+				}				
+   		}else{
+   			if(debug == 2)
+   				printk(KERN_DEBUG "IOCTL_READ_REG error param.\n");
+   		}
+   		break;
+   	}
+   	case IOCTL_SFP_WRITE:
+   	{
+   		retval = copy_from_user(&data, (const void *)arg, sizeof(SfpData_t));
+   		if(retval)
+   			return -EFAULT;
+   		if(data.rw == 0){
+				retval = sfp_write(ioBase, data.portId, data.devAddr, data.regId, data.val, data.len);
+   		}else{
+   			if(debug == 2)
+   				printk(KERN_DEBUG "IOCTL_READ_REG error param.\n");
+   		}
+   		break;
+   	}
+		default:  /* redundant, as cmd was checked against MAXNR */
+    	return( -ENOTTY );
+    }
+	DEBUG("cpld_ioctl out\n");
+	return retval;
+}
+
+static int cpld_open(struct inode *node, struct file *flip)
+{
+	//struct cpld_dev *dev;
+	//dev = container_of(node->i_cdev, struct cpld_dev, cdev);  
+	DEBUG("cpld_open in\n");
+	mutex_lock(&cpld_mutex);
+#if 1	
+	if(use_count == 0){
+		use_count += 1;
+		if(!request_region(CPLD_IO_OFF_1, CPLD_IO_REGION_1, "cpld")){
+			use_count = 0;
+			mutex_unlock(&cpld_mutex);
+			return -ENODEV;
+		}
+		if(!request_region(CPLD_IO_OFF_2, CPLD_IO_REGION_2, "cpld")){
+			use_count = 0;
+			release_region(CPLD_IO_OFF_1,CPLD_IO_REGION_1);
+			mutex_unlock(&cpld_mutex);
+			return -ENODEV;
+		}
+		if(!request_region(CPLD_IO_OFF_3, CPLD_IO_REGION_3, "cpld")){
+			use_count = 0;
+			release_region(CPLD_IO_OFF_1, CPLD_IO_REGION_1);
+			release_region(CPLD_IO_OFF_2, CPLD_IO_REGION_2);
+			mutex_unlock(&cpld_mutex);
+			return -ENODEV;
+		}
+		mutex_unlock(&cpld_mutex);
+	}
+	else{
+		use_count += 1;
+		mutex_unlock(&cpld_mutex);
+	}
+#else
+	use_count += 1;
+#endif
+	mutex_unlock(&cpld_mutex);
+	//flip->private_data = dev;	
+DEBUG("cpld_open out\n");	
+	return 0;
+}
+
+static int cpld_release(struct inode *node, struct file *flip)
+{
+#if 1
+	//struct cpld_dev *dev;
+	DEBUG("cpld_release in\n");
+	//dev = container_of(node->i_cdev, struct cpld_dev, cdev);  
+	mutex_lock(&cpld_mutex);
+	if(use_count == 0){
+		mutex_unlock(&cpld_mutex);
+		return 0;
+	}	
+	if(--use_count == 0){
+		release_region(CPLD_IO_OFF_1,CPLD_IO_REGION_1);
+		release_region(CPLD_IO_OFF_2,CPLD_IO_REGION_2);
+		release_region(CPLD_IO_OFF_3, CPLD_IO_REGION_3);
+		flip->private_data = NULL;
+	}
+	mutex_unlock(&cpld_mutex);
+#else
+	mutex_lock(&cpld_mutex);
+	if(use_count > 0){
+		use_count -= 1;
+	}
+	mutex_unlock(&cpld_mutex);	
+#endif
+	//flip->private_data = NULL;
+	DEBUG("cpld_release out\n");
+	return 0;
+}
+
+
+struct file_operations cpld_ops = 
+{
+	.owner   = THIS_MODULE,
+	.open = cpld_open,
+	.unlocked_ioctl =  cpld_ioctl,
+	.release = cpld_release,
+};
+
+//static 	struct cpld_dev *pcpld_dev = NULL;
+static int __init cpld_init(void)
+{
+#ifdef TEST
+	int ret = 0;
+	dev_t dev;
+	DEBUG("cpld_init in\n");
+	if(major){
+		dev = MKDEV(major, CPLD_MINOR);
+		ret = register_chrdev_region(dev, 1, "cpld");
+	} else{
+		ret = alloc_chrdev_region(&dev,CPLD_MINOR, 1, "cpld");
+		major = MAJOR(dev);
+	}
+	if(ret){
+		printk(KERN_ERR "Can't get the cpld device number");
+		return ret;
+	}
+		DEBUG("CPLD init\n");
+	pcpld_dev = (struct cpld_dev *)kzalloc(sizeof(struct cpld_dev), GFP_KERNEL);
+	if(NULL == pcpld_dev){
+		printk(KERN_ERR "Alloc cpld dev fail\n");
+		goto alloc_fail;
+	}
+	cdev_init(&(pcpld_dev->cdev), &cpld_ops);
+	pcpld_dev->cdev.owner = THIS_MODULE;
+	pcpld_dev->dev = dev;
+	ret = cdev_add(&(pcpld_dev->cdev), dev, 1);
+	if(ret){
+		printk(KERN_ERR "Cdev add fail\n");
+		goto add_fail;
+	}
+	pcpld_dev->ioBase = io_base;
+	DEBUG("CPLD init ioBase=0x%x\n",pcpld_dev->ioBase);
+#if 0
+	if(!request_region(IO_BASE, CPLD_IO_REGION, "cpld")){
+			printk(KERN_ERR "Request io region fail.\n");
+			ret = -ENODEV;
+			goto request_fail;
+	}
+	pcpld_dev->ioBase = ioport_map(IO_BASE,CPLD_IO_REGION);
+#endif
+	DEBUG("cpld_init out\n");
+	return ret;
+/************************************************************
+request_fail:
+	cdev_del(&(pcpld_dev->cdev));
+	***********************************************************/
+add_fail:
+DEBUG("cpld_init add_fail\n");
+	kfree(pcpld_dev);
+alloc_fail:
+DEBUG("cpld_init alloc_fail\n");
+	ret = -ENOMEM;
+	unregister_chrdev_region(dev, 1);
+	DEBUG("cpld_init  fail out\n");
+	return ret;
+#endif	
+	int ret = -1;
+
+	mutex_init(&cpld_mutex);
+
+	cpld_major = register_chrdev(0, "cpld", &cpld_ops);
+	DEBUG("cpld_major = %d\n\n",cpld_major);
+	if(cpld_major<=0) {
+		mutex_destroy(&cpld_mutex);
+		DEBUG("register chrdev error\n");
+		goto error_register_chrdev;
+	}
+
+	return 0;
+error_register_chrdev:
+	mutex_destroy(&cpld_mutex);
+	return ret;	
+}
+
+static void __exit cpld_exit(void)
+{
+//	ioport_unmap(pcpld_dev->ioBase);
+//	release_region(IO_BASE,CPLD_IO_REGION);
+DEBUG("cpld_exit in\n");
+#if 0
+	cdev_del(&(pcpld_dev->cdev));
+	kfree(pcpld_dev);
+	unregister_chrdev_region(pcpld_dev->dev, 1);	
+#endif
+	unregister_chrdev(cpld_major, "cpld");
+	mutex_destroy(&cpld_mutex);
+	DEBUG("cpld_exit out\n");	
+}
+
+module_init(cpld_init);
+module_exit(cpld_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Celestica");
+MODULE_DESCRIPTION("CPLD diver");
diff --git a/drivers/i2c/busses/i2c-ismt.c b/drivers/i2c/busses/i2c-ismt.c
index 2f95e25a10f7..fb02c76397bd 100644
--- a/drivers/i2c/busses/i2c-ismt.c
+++ b/drivers/i2c/busses/i2c-ismt.c
@@ -66,6 +66,7 @@
 #include <linux/i2c.h>
 #include <linux/acpi.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
 
 #include <linux/io-64-nonatomic-lo-hi.h>
 
@@ -307,6 +308,8 @@ static void ismt_submit_desc(struct ismt_priv *priv)
 	val = readl(priv->smba + ISMT_MSTR_MCTRL);
 	writel(val | ISMT_MCTRL_SS,
 	       priv->smba + ISMT_MSTR_MCTRL);
+	/* Fix i2c device read/write stability */
+	udelay(100);
 }
 
 /**
@@ -589,7 +592,7 @@ static int ismt_access(struct i2c_adapter *adap, u16 addr,
 	ismt_submit_desc(priv);
 
 	/* Now we wait for interrupt completion, 1s */
-	time_left = wait_for_completion_timeout(&priv->cmp, HZ*1);
+	time_left = wait_for_completion_timeout(&priv->cmp, HZ*5);
 
 	/* unmap the data buffer */
 	if (dma_size != 0)
-- 
2.27.0

